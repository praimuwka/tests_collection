# Nomia

## Задание:
![](docs/task.jpeg)

## А теперь подробнее:

### Термины:

- **Продукт**: Элемент системы, который может быть частью смеси.
- **Смесь**: Продукт, который имеет набор составных ингридиентов. 

Каждая смесь может служить ингридиентом для другой смеси (одной или нескольких).  
Это значит что мы имеем отношение "многие ко многим", и связи между продуктами нельзя представить в виде иерархии уникальных элементов.  
Также следует учесть что многие листья могут повторяться.

![](docs/tree1.PNG)

### А теперь на языке графов:

Каждый продукт представляет собой узел направленного графа, а связи между продуктами - его ребра.  

Для решения задачи нужно предотвратить появление в графе циклических зависимостей.  
Для этого достаточно перед добавлением продукта A в продукт B проверить, существует ли между ними маршрут.  
Чтобы проверить наличие маршрута A->B (или B->A) лучше всего использовать алгоритм поиска элемента X в узле Y.

## Подходы к решению:

Для поиска можно использовать два подхода к обходу графа:

1. **Обход сверху вниз**: Начинается с корневого узла (продукта) и движется вниз по дереву, проверяя каждый узел на наличие искомого элемента.  
Ссылка на класс: [Product (1)](src/main/java/approach1/Product.java)
2. **Обход снизу вверх**: Начинается с листового узла (продукта) и движется вверх по дереву, также проверяя каждый узел на наличие искомого элемента.   
Ссылка на класс: [Product (2)](src/main/java/approach2/Product.java)  

В обоих случаях будем использовать алгоритм DFS (обход в глубину),
поскольку при движении в обоих направлениях порядок связей будет образовывать дерево.

![](docs/trees2.PNG)  

Картинка иллюстрирует, что листьев (ингридиентов) либо больше, либо они чаще повторяются, из-за чего второй способ должен работать эффективнее.  

Также, чтобы дополнительно повысить эффективность поиска следует предотвратить повторное сканирование уже посещенных узлов.
## Результаты:
Для проверки работы алгоритма, при помощи класса [DataGenerator](src/main/java/utils/DataGenerator.java) , были сгенерированы 10_000 продуктов, каждый из которых может служить ингридиентом для N смесей.
Кол-во смесей, а также идентификатор каждой смеси определяется случайным образом. 

При помощи класса [NomiaTask](src/main/java/NomiaTask.java) было произведено тестирование работы алгоритмов на сгенерированных данных.  
Далее представлены результаты работы алгоритмов.  
Также можно наблюдать влияние параметра N (количество возможных смесей) на процесс обработки:

Здесь продукт может быть добавлен в одну из смесей от 0 до 5 раз:  
![](docs/res5.PNG)

Здесь продукт может быть добавлен в одну из смесей от 0 до 10 раз:  
![](docs/res10.PNG)

По статистике на картинках видно, что система корректно обрабатывает данные о продуктах и их смесях.  
Оба подхода выдают аналогичный результат, но при этом требуют разное количество времени на обработку.  

Также очевидно что второй подход работает намного быстрее.  

Несмотря на то что и там и там используется алгоритм DFS
(и казалось бы сложность алгоритма должна быть сопоставимой), понимание природы данных позволяет использовать алгоритм более эффективно :-)
